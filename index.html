<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PWA Fases</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#3b82f6"> 
    <style>
    /* ---- Estilos Globales y de Contenedores Principales ---- */
    html, body {
        height: 100%; /* Ocupar toda la altura del viewport */
        margin: 0;
        padding: 0;
        overflow: hidden; /* CRÍTICO: Evita el scroll en html y body */
        /* El font-family y colores base son manejados por las clases de Tailwind en <body> */
    }

    body {
        position: relative; /* Contexto para elementos posicionados absolutamente como el menú de opciones */
    }

    #app-container {
        width: 100%;
        height: 100%; /* Ocupar todo el espacio de body */
        overflow: hidden; /* CRÍTICO: #app-container es el viewport para las pantallas */
        position: relative; /* Contexto para las pantallas posicionadas absolutamente */
    }

    /* ---- Estilos de Pantalla (.screen y .active-screen) ---- */
    .screen {
        display: none; /* Ocultar pantallas inactivas */
        width: 100%;
        height: 100%;
        position: absolute; /* Posicionar absolutamente dentro de #app-container */
        top: 0;
        left: 0;
        background-color: inherit; /* Heredar color de fondo de body (manejado por Tailwind) */
        /* Asegura que las transiciones de tema se apliquen bien si el fondo es importante aquí */
    }

    .active-screen {
        display: flex;       /* Usar flex para la estructura interna (header, main) */
        flex-direction: column;
        overflow: hidden;    /* CRÍTICO: La pantalla activa en sí no debe hacer scroll. */
                             /* Las partes internas pueden tener su propio scroll. */
    }

    /* ---- Estilos Específicos y Previamente Definidos ---- */
    /* Líneas separadoras para Fase 1 */
    .separator-line {
        width: 1px;
        background-color: #9ca3af; /* gris-400 */
        align-self: stretch;
    }
    .dark .separator-line {
        background-color: #4b5563; /* gris-600 en modo oscuro */
    }

    /* Imágenes de Fase 1 */
    .fase-image {
        width: 20vh;
        height: 20vh;
        object-fit: cover;
        margin-left: auto;
        margin-right: auto;
        border-radius: 0.375rem; /* rounded-md */
        cursor: pointer;
        background-color: #e5e7eb; /* bg-gray-200 */
    }
    .dark .fase-image {
        background-color: #374151; /* bg-gray-700 */
    }

    /* Scroll para el área de contenido principal de main-screen */
    /* Se dirige al <main> que es hijo directo de #main-screen */
    #main-screen > main {
        overflow-y: auto; /* Permite scroll solo en el contenedor de botones */
    }

    /* Fase 1: las columnas internas ya tienen overflow-y: auto y h-full/h-[90vh]
       La estructura de Fase 1 (header + main > div.h-[90vh] > columnas scrollables)
       debería funcionar bien dentro de .active-screen (que tiene overflow:hidden).
       El main de Fase 1 usará flex-grow para ocupar el espacio restante tras el header.
    */
</style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-gray-100 font-sans transition-colors duration-300">

    <div id="app-container">

        <!-- <div id="main-screen" class="screen active-screen">
            <header class="p-4 bg-blue-500 dark:bg-blue-700 text-white flex justify-between items-center shadow-md sticky top-0 z-10">
                <h1 class="text-2xl font-bold">Aplicación de Fases</h1>
                <button id="hamburger-btn" aria-label="Abrir menú de opciones" class="p-2 rounded-md hover:bg-blue-600 dark:hover:bg-blue-800 focus:outline-none focus:ring-2 focus:ring-white">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-7 h-7">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5" />
                    </svg>
                </button>
            </header>
            <main class="flex-grow p-6 grid grid-cols-2 sm:grid-cols-3 gap-5 justify-items-center items-center">
                </main>
        </div> -->


        <div id="main-screen" class="screen active-screen"> <header class="p-4 bg-blue-500 dark:bg-blue-700 text-white flex justify-between items-center shadow-md sticky top-0 z-10">
                <h1 class="text-2xl font-bold">PECS for Luka</h1>
                <button id="hamburger-btn" aria-label="Abrir menú de opciones" class="p-2 rounded-md hover:bg-blue-600 dark:hover:bg-blue-800 focus:outline-none focus:ring-2 focus:ring-white">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-7 h-7">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5" />
                    </svg>
                </button>
            </header>
            <main class="flex-grow p-6 grid grid-cols-2 sm:grid-cols-3 gap-5 justify-items-center items-center">
                </main>
        </div>


        <div id="fase-1-screen" class="screen hidden">
            <header class="p-4 bg-green-500 dark:bg-green-700 text-white flex justify-between items-center shadow-md sticky top-0 z-10">
                <button class="back-to-main p-2 rounded-md hover:bg-green-600 dark:hover:bg-green-800 focus:outline-none focus:ring-2 focus:ring-white" aria-label="Volver al menú principal">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-7 h-7">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5L8.25 12l7.5-7.5" />
                    </svg>
                </button>
                <h1 class="text-2xl font-bold">Fase 1</h1>
                <div class="w-7 h-7"></div> 
            </header>
            <main class="flex-grow flex justify-center items-start pt-4 pb-4 sm:pt-6 sm:pb-6" style="padding-left: calc(100vw / 30); padding-right: calc(100vw / 30);">
                <div class="flex w-full h-[90vh]" style="gap: calc(100vw / 60);">
                    <div id="fase1-col1" class="bg-gray-200 dark:bg-gray-700 rounded-lg overflow-y-auto p-3 space-y-4" style="width: 30vw; height: 100%;">
                        </div>
                    <div class="separator-line"></div>
                    <div id="fase1-col2" class="bg-gray-200 dark:bg-gray-700 rounded-lg overflow-y-auto p-3 space-y-4" style="width: 30vw; height: 100%;">
                        </div>
                    <div class="separator-line"></div>
                    <div id="fase1-col3" class="bg-gray-200 dark:bg-gray-700 rounded-lg overflow-y-auto p-3 space-y-4" style="width: 30vw; height: 100%;">
                        </div>
                </div>
            </main>
        </div>

        <div id="fase-2-screen" class="screen hidden">
            <header class="p-4 bg-yellow-500 dark:bg-yellow-700 text-white flex justify-between items-center shadow-md sticky top-0 z-10 w-full"><button class="back-to-main p-2 rounded-md hover:bg-yellow-600 dark:hover:bg-yellow-800 focus:outline-none focus:ring-2 focus:ring-white" aria-label="Volver al menú principal"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-7 h-7"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5L8.25 12l7.5-7.5" /></svg></button><h1 class="text-2xl font-bold">Fase 2</h1><div class="w-7 h-7"></div></header>
            <main class="flex-grow flex justify-center items-start pt-4 pb-4 sm:pt-6 sm:pb-6" style="padding-left: calc(100vw / 30); padding-right: calc(100vw / 30);">
                <div class="flex w-full h-[90vh]" style="gap: calc(100vw / 60);">
                    <div id="fase2-col1" class="bg-gray-200 dark:bg-gray-700 rounded-lg overflow-y-auto p-3 space-y-4" style="width: 30vw; height: 100%;">
                        </div>
                    <div class="separator-line"></div>
                    <div id="fase2-col2" class="bg-gray-200 dark:bg-gray-700 rounded-lg overflow-y-auto p-3 space-y-4" style="width: 30vw; height: 100%;">
                        </div>
                    <div class="separator-line"></div>
                    <div id="fase2-col3" class="bg-gray-200 dark:bg-gray-700 rounded-lg overflow-y-auto p-3 space-y-4" style="width: 30vw; height: 100%;">
                        </div>
                </div>
            </main>
        </div>
        <div id="fase-3-screen" class="screen hidden">
            <header class="p-4 bg-purple-500 dark:bg-purple-700 text-white flex justify-between items-center shadow-md sticky top-0 z-10 w-full"><button class="back-to-main p-2 rounded-md hover:bg-purple-600 dark:hover:bg-purple-800 focus:outline-none focus:ring-2 focus:ring-white" aria-label="Volver al menú principal"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-7 h-7"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5L8.25 12l7.5-7.5" /></svg></button><h1 class="text-2xl font-bold">Fase 3</h1><div class="w-7 h-7"></div></header>
            <main class="flex-grow flex justify-center items-start pt-4 pb-4 sm:pt-6 sm:pb-6" style="padding-left: calc(100vw / 30); padding-right: calc(100vw / 30);">
                <div class="flex w-full h-[90vh]" style="gap: calc(100vw / 60);">
                    <div id="fase3-col1" class="bg-gray-200 dark:bg-gray-700 rounded-lg overflow-y-auto p-3 space-y-4" style="width: 30vw; height: 100%;">
                        </div>
                    <div class="separator-line"></div>
                    <div id="fase3-col2" class="bg-gray-200 dark:bg-gray-700 rounded-lg overflow-y-auto p-3 space-y-4" style="width: 30vw; height: 100%;">
                        </div>
                    <div class="separator-line"></div>
                    <div id="fase3-col3" class="bg-gray-200 dark:bg-gray-700 rounded-lg overflow-y-auto p-3 space-y-4" style="width: 30vw; height: 100%;">
                        </div>
                </div>
            </main>
        </div>
        <div id="fase-4-screen" class="screen hidden">
            <header class="p-4 bg-pink-500 dark:bg-pink-700 text-white flex justify-between items-center shadow-md sticky top-0 z-10 w-full"><button class="back-to-main p-2 rounded-md hover:bg-pink-600 dark:hover:bg-pink-800 focus:outline-none focus:ring-2 focus:ring-white" aria-label="Volver al menú principal"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-7 h-7"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5L8.25 12l7.5-7.5" /></svg></button><h1 class="text-2xl font-bold">Fase 4</h1><div class="w-7 h-7"></div></header>
            <main class="flex-grow flex justify-center items-start pt-4 pb-4 sm:pt-6 sm:pb-6" style="padding-left: calc(100vw / 30); padding-right: calc(100vw / 30);">
                <div class="flex w-full h-[90vh]" style="gap: calc(100vw / 60);">
                    <div id="fase4-col1" class="bg-gray-200 dark:bg-gray-700 rounded-lg overflow-y-auto p-3 space-y-4" style="width: 30vw; height: 100%;">
                        </div>
                    <div class="separator-line"></div>
                    <div id="fase4-col2" class="bg-gray-200 dark:bg-gray-700 rounded-lg overflow-y-auto p-3 space-y-4" style="width: 30vw; height: 100%;">
                        </div>
                    <div class="separator-line"></div>
                    <div id="fase4-col3" class="bg-gray-200 dark:bg-gray-700 rounded-lg overflow-y-auto p-3 space-y-4" style="width: 30vw; height: 100%;">
                        </div>
                </div>
            </main>
        </div>
        <div id="fase-5-screen" class="screen hidden">
            <header class="p-4 bg-indigo-500 dark:bg-indigo-700 text-white flex justify-between items-center shadow-md sticky top-0 z-10 w-full"><button class="back-to-main p-2 rounded-md hover:bg-indigo-600 dark:hover:bg-indigo-800 focus:outline-none focus:ring-2 focus:ring-white" aria-label="Volver al menú principal"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-7 h-7"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5L8.25 12l7.5-7.5" /></svg></button><h1 class="text-2xl font-bold">Fase 5</h1><div class="w-7 h-7"></div></header>
            <main class="flex-grow flex justify-center items-start pt-4 pb-4 sm:pt-6 sm:pb-6" style="padding-left: calc(100vw / 30); padding-right: calc(100vw / 30);">
                <div class="flex w-full h-[90vh]" style="gap: calc(100vw / 60);">
                    <div id="fase5-col1" class="bg-gray-200 dark:bg-gray-700 rounded-lg overflow-y-auto p-3 space-y-4" style="width: 30vw; height: 100%;">
                        </div>
                    <div class="separator-line"></div>
                    <div id="fase5-col2" class="bg-gray-200 dark:bg-gray-700 rounded-lg overflow-y-auto p-3 space-y-4" style="width: 30vw; height: 100%;">
                        </div>
                    <div class="separator-line"></div>
                    <div id="fase5-col3" class="bg-gray-200 dark:bg-gray-700 rounded-lg overflow-y-auto p-3 space-y-4" style="width: 30vw; height: 100%;">
                        </div>
                </div>
            </main>
        </div>
        <div id="fase-6-screen" class="screen hidden">
            <header class="p-4 bg-teal-500 dark:bg-teal-700 text-white flex justify-between items-center shadow-md sticky top-0 z-10 w-full"><button class="back-to-main p-2 rounded-md hover:bg-teal-600 dark:hover:bg-teal-800 focus:outline-none focus:ring-2 focus:ring-white" aria-label="Volver al menú principal"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-7 h-7"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5L8.25 12l7.5-7.5" /></svg></button><h1 class="text-2xl font-bold">Fase 6</h1><div class="w-7 h-7"></div></header>
            <main class="flex-grow flex justify-center items-start pt-4 pb-4 sm:pt-6 sm:pb-6" style="padding-left: calc(100vw / 30); padding-right: calc(100vw / 30);">
                <div class="flex w-full h-[90vh]" style="gap: calc(100vw / 60);">
                    <div id="fase6-col1" class="bg-gray-200 dark:bg-gray-700 rounded-lg overflow-y-auto p-3 space-y-4" style="width: 30vw; height: 100%;">
                        </div>
                    <div class="separator-line"></div>
                    <div id="fase6-col2" class="bg-gray-200 dark:bg-gray-700 rounded-lg overflow-y-auto p-3 space-y-4" style="width: 30vw; height: 100%;">
                        </div>
                    <div class="separator-line"></div>
                    <div id="fase6-col3" class="bg-gray-200 dark:bg-gray-700 rounded-lg overflow-y-auto p-3 space-y-4" style="width: 30vw; height: 100%;">
                        </div>
                </div>
            </main>
        </div>

    </div>

    <div id="options-overlay" class="fixed inset-0 bg-black bg-opacity-50 hidden z-40 transition-opacity duration-300"></div>
    <div id="options-menu" class="fixed top-0 left-0 w-72 sm:w-80 h-full bg-white dark:bg-gray-800 shadow-xl p-6 transform -translate-x-full transition-transform duration-300 ease-in-out z-50 flex flex-col">
    <div class="flex justify-between items-center mb-6">
        <h2 class="text-xl font-semibold">Opciones</h2>
        <button id="close-options-btn" aria-label="Cerrar menú de opciones" class="p-2 rounded-md hover:bg-gray-200 dark:hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-blue-500">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-7 h-7">
              <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
            </svg>
        </button>
    </div>
    
    <div class="mb-6">
        <h3 class="text-lg font-medium mb-2 text-gray-800 dark:text-gray-200">APARIENCIA</h3>
        <label for="theme-selector" class="block mb-2 text-sm font-medium text-gray-700 dark:text-gray-300">Modo de Visualización:</label>
        <select id="theme-selector" class="bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-3 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-blue-500 dark:focus:border-blue-500">
            <option value="light">Claro</option>
            <option value="dark">Oscuro</option>
            <option value="system">Automático (Sistema)</option>
        </select>
    </div>

    <div class="mb-6 border-t border-gray-300 dark:border-gray-600 pt-4">
        <h3 class="text-lg font-medium mb-3 text-gray-800 dark:text-gray-200">VOZ (TEXT-TO-SPEECH)</h3>
        
        <div class="mb-4">
            <label for="tts-language-selector" class="block mb-1 text-sm font-medium text-gray-700 dark:text-gray-300">Idioma para Voces:</label>
            <select id="tts-language-selector" class="bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-3 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-blue-500 dark:focus:border-blue-500">
                <option value="">Cargando idiomas...</option>
            </select>
        </div>

        <div class="mb-4">
            <label for="voice-selector" class="block mb-1 text-sm font-medium text-gray-700 dark:text-gray-300">Voz:</label>
            <select id="voice-selector" class="bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-3 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-blue-500 dark:focus:border-blue-500">
                <option value="">Seleccione un idioma primero...</option>
            </select>
        </div>

        <div class="mb-4">
            <label for="voice-rate" class="block mb-1 text-sm font-medium text-gray-700 dark:text-gray-300">Velocidad: <span id="voice-rate-value" class="font-normal">1.0</span></label>
            <input type="range" id="voice-rate" min="0.5" max="2" step="0.1" value="1.0" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer dark:bg-gray-700">
        </div>

        <div class="mb-4">
            <label for="voice-pitch" class="block mb-1 text-sm font-medium text-gray-700 dark:text-gray-300">Tono: <span id="voice-pitch-value" class="font-normal">1.0</span></label>
            <input type="range" id="voice-pitch" min="0" max="2" step="0.1" value="1.0" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer dark:bg-gray-700">
        </div>

        <div class="mb-4">
            <label for="voice-volume" class="block mb-1 text-sm font-medium text-gray-700 dark:text-gray-300">Volumen: <span id="voice-volume-value" class="font-normal">1.0</span></label>
            <input type="range" id="voice-volume" min="0" max="1" step="0.1" value="1.0" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer dark:bg-gray-700">
        </div>
    </div>
    
    <button id="apply-changes-btn" class="mt-auto w-full bg-blue-500 hover:bg-blue-600 dark:bg-blue-600 dark:hover:bg-blue-700 text-white font-semibold py-3 px-4 rounded-lg shadow-md focus:outline-none focus:ring-2 focus:ring-blue-400 dark:focus:ring-blue-500 transition-colors duration-150">
        Aplicar Cambios
    </button>
    <div class="mt-4 text-xs text-gray-500 dark:text-gray-400 text-center">
        PWA Fases v1.2 </div>
</div>

<script>
        // MODIFIED: Added async to DOMContentLoaded callback
    document.addEventListener('DOMContentLoaded', async () => {
        // --- Selectores de Elementos ---
        const appContainer = document.getElementById('app-container');
        const mainScreen = document.getElementById('main-screen');
        const hamburgerBtn = document.getElementById('hamburger-btn');
        const optionsMenu = document.getElementById('options-menu');
        const optionsOverlay = document.getElementById('options-overlay');
        const closeOptionsBtn = document.getElementById('close-options-btn');
        
        const screens = document.querySelectorAll('.screen');
        const backToMainBtns = document.querySelectorAll('.back-to-main');

        // Selectores para Opciones de Apariencia
        const themeSelector = document.getElementById('theme-selector');
        
        // Selectores para Opciones de Voz (TTS)
        const ttsLanguageSelectorElement = document.getElementById('tts-language-selector'); // Selector de Idioma TTS
        const voiceSelectorElement = document.getElementById('voice-selector');
        const voiceRateElement = document.getElementById('voice-rate');
        const voiceRateValueElement = document.getElementById('voice-rate-value');
        const voicePitchElement = document.getElementById('voice-pitch');
        const voicePitchValueElement = document.getElementById('voice-pitch-value');
        const voiceVolumeElement = document.getElementById('voice-volume');
        const voiceVolumeValueElement = document.getElementById('voice-volume-value');
        
        const applyChangesBtn = document.getElementById('apply-changes-btn');

        // --- Configuración Global de TTS ---
        let ttsSettings = {
            userPreferredLang: '',   // Idioma base seleccionado por el usuario para filtrar voces (ej: "es", "en")
            selectedVoiceName: '',   // Nombre de la voz específica elegida
            utteranceLang: '',       // Idioma exacto de la voz seleccionada para el utterance (ej: "es-ES", "en-US")
            rate: 1.0,
            pitch: 1.0,
            volume: 1.0
        };
        let availableVoices = []; // Almacenará las voces cargadas

        // --- Global App Data Store ---
        const appData = {
            allFasesData: {} // Will be populated from CSV
        };

        // --- CSV Loading and Parsing ---
        async function loadFaseDataFromCSV() {
            const lang = ttsSettings.userPreferredLang || getBrowserBaseLanguage();
            const fileName = lang.startsWith("es") ? "esp_fase_data.csv" : "eng_fase_data.csv";
            console.log(`Loading data from ${fileName}`);

            try {
                const response = await fetch(fileName);
                if (!response.ok) {
                    console.error(`Error fetching ${fileName}: ${response.statusText}`);
                    appData.allFasesData = {}; // Clear or set to default empty structure
                    return false;
                }
                const csvText = await response.text();
                const lines = csvText.trim().split('\n');
                if (lines.length < 1) { console.error("CSV file is empty or invalid"); appData.allFasesData = {}; return false; }
                const headers = lines[0].split(',').map(header => header.trim());
                const data = {};

                for (let i = 1; i < lines.length; i++) {
                    // ---- DETAILED LOGGING FOR FASE1 START ----
                    const current_line_content_for_debug = lines[i];
                    // ---- DETAILED LOGGING FOR FASE1 END ----
                    const values = lines[i].split(','); // No trim here, handle if values can have spaces
                    const entry = {};
                    headers.forEach((header, index) => {
                        entry[header] = values[index] ? values[index].trim() : "";
                    });

                    // ---- DETAILED LOGGING FOR FASE1 START ----
                    if (entry.fase_id === "fase1") {
                        console.log("Processing entry for fase1:", JSON.parse(JSON.stringify(entry)), "Raw line:", current_line_content_for_debug);
                        console.log("Check conditions for fase1 item: item_id=", entry.item_id, "image_url=", entry.image_url);
                    }
                    // ---- DETAILED LOGGING FOR FASE1 END ----
                    if (!entry.fase_id || !entry.collection_id) continue;

                    if (!data[entry.fase_id]) {
                        data[entry.fase_id] = {};
                    }
                    if (!data[entry.fase_id][entry.collection_id]) {
                        data[entry.fase_id][entry.collection_id] = [];
                    }

                    if (entry.item_id && entry.image_url) { // Ensure essential item data exists
                         data[entry.fase_id][entry.collection_id].push({
                            item_id: entry.item_id,
                            src: entry.image_url,
                            speech: entry.speech_text,
                            alt: entry.alt_text
                        });
                    }
                }
                    // ---- DETAILED LOGGING FOR FASE1 START ----
                    if (data.fase1) {
                        console.log("Final data object for fase1 before assignment:", JSON.parse(JSON.stringify(data.fase1)));
                    } else {
                        console.log("No data.fase1 object was created.");
                    }
                    // ---- DETAILED LOGGING FOR FASE1 END ----
                appData.allFasesData = data;
                console.log("Fase data loaded and parsed:", appData.allFasesData);
                    console.log("loadFaseDataFromCSV successfully parsed. Returning true.");
                return true;
            } catch (error) {
                console.error("Failed to load or parse CSV data:", error);
                appData.allFasesData = {};
                    console.log("loadFaseDataFromCSV encountered an issue. Returning false.");
                return false;
            }
        }

        // --- Funciones ---
        function showScreen(screenId) {
            if (!screens) return;
            screens.forEach(screen => {
                if (screen.id === screenId) {
                    screen.classList.remove('hidden');
                    screen.classList.add('active-screen');
                    if (screen.id.startsWith("fase-") && screen.id.endsWith("-screen")) {
                        // MODIFIED: Ensure faseId matches CSV key format (e.g., "fase1")
                        const faseId = screen.id.substring(0, screen.id.indexOf("-screen")).replace("-", "");
                        displayFaseContent(faseId);
                    }
                } else {
                    screen.classList.add('hidden');
                    screen.classList.remove('active-screen');
                }
            });
            window.scrollTo(0, 0);
        }

        function toggleOptionsMenu(show) {
            if (!optionsMenu || !optionsOverlay) return;
            if (show) {
                optionsOverlay.classList.remove('hidden');
                optionsMenu.classList.remove('-translate-x-full');
                optionsMenu.classList.add('translate-x-0');
                optionsOverlay.classList.add('opacity-50');
                optionsOverlay.classList.remove('opacity-0');
            } else {
                optionsMenu.classList.add('-translate-x-full');
                optionsMenu.classList.remove('translate-x-0');
                optionsOverlay.classList.add('opacity-0');
                optionsOverlay.classList.remove('opacity-50');
                setTimeout(() => {
                    optionsOverlay.classList.add('hidden');
                }, 300);
            }
        }
        
        function applyTheme(theme) {
            if (theme === 'dark' || (theme === 'system' && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
            localStorage.setItem('theme', theme);
        }

        function getBrowserBaseLanguage() {
            const lang = navigator.language || navigator.userLanguage || 'es'; // Fallback a 'es'
            return lang.split('-')[0]; // Retorna la parte base, ej: "es" de "es-AR"
        }
        
        function populateLanguageSelector() {
            if (!ttsLanguageSelectorElement || availableVoices.length === 0) {
                if(ttsLanguageSelectorElement) ttsLanguageSelectorElement.innerHTML = '<option value="">No hay idiomas disponibles</option>';
                return;
            }

            const baseLangs = [...new Set(availableVoices.map(voice => voice.lang.split('-')[0]))].sort();
            // Usar el userPreferredLang ya cargado/inicializado para la selección
            const currentSelectedLang = ttsSettings.userPreferredLang; 
            
            ttsLanguageSelectorElement.innerHTML = ''; 

            if (baseLangs.length === 0) {
                 ttsLanguageSelectorElement.innerHTML = '<option value="">No hay idiomas</option>';
                 return;
            }

            baseLangs.forEach(langCode => {
                const option = document.createElement('option');
                option.value = langCode;
                try {
                    let displayName = langCode;
                    // Para obtener el nombre del idioma en el propio idioma (ej. "Español" en vez de "Spanish")
                    // se podría usar new Intl.DisplayNames([langCode], { type: 'language' }).of(langCode);
                    // pero para una lista de idiomas, es más común mostrarlos en el idioma de la UI.
                    // Aquí lo mostramos en el idioma del código mismo si es posible, o el código.
                    const languageNames = new Intl.DisplayNames([langCode], { type: 'language' }); // Usar el idioma del código para el nombre
                    displayName = languageNames.of(langCode);
                    option.textContent = displayName.charAt(0).toUpperCase() + displayName.slice(1);
                } catch (e) {
                    option.textContent = langCode.toUpperCase(); 
                }
                ttsLanguageSelectorElement.appendChild(option);
            });
            
            if (baseLangs.includes(currentSelectedLang)) {
                ttsLanguageSelectorElement.value = currentSelectedLang;
            } else if (baseLangs.length > 0) { // Si el preferido no está, seleccionar el primero de la lista
                ttsLanguageSelectorElement.value = baseLangs[0];
            }
            // Actualizar ttsSettings.userPreferredLang con el valor que realmente quedó seleccionado
            ttsSettings.userPreferredLang = ttsLanguageSelectorElement.value;
        }

        function populateVoiceSelector() {
            if (!voiceSelectorElement) return;
            
            const filterLang = ttsSettings.userPreferredLang;
            const previouslySelectedVoiceName = ttsSettings.selectedVoiceName;
            voiceSelectorElement.innerHTML = '';

            const defaultOption = document.createElement('option');
            defaultOption.value = ""; 
            defaultOption.textContent = "Voz por defecto del navegador";
            voiceSelectorElement.appendChild(defaultOption);

            if (!filterLang && availableVoices.length > 0) { // Si no hay idioma de filtro, mostrar mensaje o todas las voces
                 const placeholderOption = document.createElement('option');
                 placeholderOption.textContent = "Seleccione un idioma";
                 placeholderOption.disabled = true;
                 voiceSelectorElement.appendChild(placeholderOption);
                 updateUtteranceLangFromSelection(); // Ajustar el idioma del utterance
                 return;
            }
            
            const filteredVoices = availableVoices.filter(voice => voice.lang.startsWith(filterLang));

            if (filteredVoices.length === 0) {
                const noVoiceOption = document.createElement('option');
                noVoiceOption.value = ""; // Para que no parezca una voz seleccionable
                noVoiceOption.textContent = "No hay voces para este idioma";
                noVoiceOption.disabled = true;
                voiceSelectorElement.appendChild(noVoiceOption);
                updateUtteranceLangFromSelection();
                return;
            }
            
            filteredVoices.forEach(voice => {
                const option = document.createElement('option');
                option.textContent = `${voice.name} (${voice.lang})`;
                option.value = voice.name;
                option.setAttribute('data-lang', voice.lang); 
                voiceSelectorElement.appendChild(option);
            });
            
            if (previouslySelectedVoiceName) {
                const voiceExistsInFiltered = filteredVoices.some(v => v.name === previouslySelectedVoiceName);
                if (voiceExistsInFiltered) {
                    voiceSelectorElement.value = previouslySelectedVoiceName;
                } else {
                    // La voz guardada no corresponde al idioma filtrado, se seleccionará "Voz por defecto"
                    ttsSettings.selectedVoiceName = ""; 
                }
            }
            updateUtteranceLangFromSelection(); 
        }
        
        function updateUtteranceLangFromSelection() {
            if (!voiceSelectorElement) return;
            const selectedVoiceOption = voiceSelectorElement.options[voiceSelectorElement.selectedIndex];
            if (selectedVoiceOption && selectedVoiceOption.value !== "" && selectedVoiceOption.dataset.lang) { 
                ttsSettings.utteranceLang = selectedVoiceOption.dataset.lang;
            } else { 
                ttsSettings.utteranceLang = ttsSettings.userPreferredLang || getBrowserBaseLanguage();
            }
        }

        function loadTTSSettingsFromLocalStorage() {
            ttsSettings.userPreferredLang = localStorage.getItem('ttsUserPreferredLang') || getBrowserBaseLanguage();
            ttsSettings.selectedVoiceName = localStorage.getItem('ttsSelectedVoiceName') || '';
            // utteranceLang se carga aquí, pero se refinará después de cargar voces y seleccionar una
            ttsSettings.utteranceLang = localStorage.getItem('ttsUtteranceLang') || ttsSettings.userPreferredLang;
            ttsSettings.rate = parseFloat(localStorage.getItem('ttsRate') || 1.0);
            ttsSettings.pitch = parseFloat(localStorage.getItem('ttsPitch') || 1.0);
            ttsSettings.volume = parseFloat(localStorage.getItem('ttsVolume') || 1.0);

            if (voiceRateElement) {
                voiceRateElement.value = ttsSettings.rate;
                if (voiceRateValueElement) voiceRateValueElement.textContent = ttsSettings.rate.toFixed(1);
            }
            if (voicePitchElement) {
                voicePitchElement.value = ttsSettings.pitch;
                if (voicePitchValueElement) voicePitchValueElement.textContent = ttsSettings.pitch.toFixed(1);
            }
            if (voiceVolumeElement) {
                voiceVolumeElement.value = ttsSettings.volume;
                if (voiceVolumeValueElement) voiceVolumeValueElement.textContent = ttsSettings.volume.toFixed(1);
            }
        }
        
        function initializeTTS() {
            if (typeof speechSynthesis === 'undefined') {
                console.warn("Speech Synthesis no soportado.");
                [ttsLanguageSelectorElement, voiceSelectorElement, voiceRateElement, voicePitchElement, voiceVolumeElement].forEach(el => {
                    if (el) el.disabled = true;
                });
                if(ttsLanguageSelectorElement) ttsLanguageSelectorElement.innerHTML = '<option value="">TTS no disponible</option>';
                if(voiceSelectorElement) voiceSelectorElement.innerHTML = '<option value="">TTS no disponible</option>';
                return;
            }

            loadTTSSettingsFromLocalStorage(); // Cargar primero las configuraciones de localStorage

            availableVoices = window.speechSynthesis.getVoices();
            if (availableVoices.length > 0) {
                populateLanguageSelector(); // Poblar idiomas y seleccionar el guardado/default. Esto actualiza ttsSettings.userPreferredLang.
                populateVoiceSelector();    // Poblar voces filtradas por userPreferredLang y seleccionar la guardada/default. Esto actualiza ttsSettings.utteranceLang.
            } else {
                // Si las voces no están listas, onvoiceschanged se encargará
                if(ttsLanguageSelectorElement) ttsLanguageSelectorElement.innerHTML = '<option value="">Cargando idiomas...</option>';
                if(voiceSelectorElement) voiceSelectorElement.innerHTML = '<option value="">Cargando voces...</option>';
            }
        }

        function speak(text) { 
            if (!('speechSynthesis' in window)) {
                console.warn('Text-to-Speech no es soportado.');
                alert('Tu navegador no soporta la función de voz.');
                return;
            }
            window.speechSynthesis.cancel(); 

            const utterance = new SpeechSynthesisUtterance(text);
            utterance.text = text;
            utterance.lang = ttsSettings.utteranceLang; 
            utterance.rate = ttsSettings.rate;
            utterance.pitch = ttsSettings.pitch;
            utterance.volume = ttsSettings.volume;

            if (ttsSettings.selectedVoiceName) {
                const voice = availableVoices.find(v => v.name === ttsSettings.selectedVoiceName);
                if (voice) {
                    utterance.voice = voice;
                    // Asegurar que el lang del utterance coincida con el de la voz seleccionada si es específica
                    utterance.lang = voice.lang; 
                } else {
                    console.warn(`Voz "${ttsSettings.selectedVoiceName}" no encontrada. Usando voz por defecto para ${ttsSettings.utteranceLang}.`);
                }
            }
            
            utterance.onerror = (event) => { console.error("Error en TTS:", event.error); };
            window.speechSynthesis.speak(utterance);
        }
        
        function displayFaseContent(faseId) {
            console.log(`Displaying content for ${faseId}`);
            const faseData = appData.allFasesData[faseId];

            if (!faseData) {
                console.warn(`No data found for ${faseId}. Clearing content.`);
                // Optionally clear content for all potential columns if structure is known
                for (let i = 1; i <= 3; i++) { // Assuming max 3 columns for now
                    const columnElement = document.getElementById(`${faseId}-col${i}`);
                    if (columnElement) columnElement.innerHTML = "";
                }
                return;
            }

            Object.keys(faseData).forEach(collectionId => {
                const columnElement = document.getElementById(`${faseId}-${collectionId}`);
                const imageData = faseData[collectionId];

                if (!columnElement) {
                    console.warn(`Column element not found: ${faseId}-${collectionId}`);
                    return; // Skip this collection if its DOM element doesnt exist
                }
                columnElement.innerHTML = ""; // Clear previous content

                if (imageData && imageData.length > 0) {
                    imageData.forEach(imgData => {
                        if (!imgData.src) return; // Skip if no image source
                        const img = document.createElement("img");
                        img.src = imgData.src;
                        img.alt = imgData.alt;
                        img.className = "fase-image"; // Existing class for styling
                        img.dataset.speech = imgData.speech;
                        img.onerror = function() {
                            this.onerror=null;
                            const placeholderSize = Math.round(window.innerHeight * 0.2);
                            this.src=`https://placehold.co/${placeholderSize}x${placeholderSize}/cccccc/969696?text=Error`;
                            this.alt = "Error al cargar imagen";
                        };
                        img.addEventListener("click", () => speak(imgData.speech));
                        columnElement.appendChild(img);
                    });
                } else {
                    // console.log(`No items for ${faseId}-${collectionId}`);
                    // columnElement.innerHTML = "<p class=\"text-sm text-gray-500\">No items available.</p>"; // Optional: display message
                }
            });
        }

        // --- INICIALIZACIÓN DE LA UI PRINCIPAL ---
        if (mainScreen) {
            const mainScreenContent = mainScreen.querySelector('main');
            if (mainScreenContent) {
                for (let i = 1; i <= 6; i++) {
                    const faseBtn = document.createElement('button');
                    faseBtn.className = 'fase-btn bg-white dark:bg-gray-700 dark:hover:bg-gray-600 hover:bg-gray-50 text-blue-500 dark:text-blue-400 font-semibold py-8 px-4 border border-blue-300 dark:border-gray-600 rounded-xl shadow-lg hover:shadow-xl transform hover:scale-105 transition-all duration-200 ease-in-out focus:outline-none focus:ring-2 focus:ring-blue-400 dark:focus:ring-blue-500 text-lg sm:text-xl';
                    faseBtn.textContent = `Fase ${i}`;
                    faseBtn.dataset.targetScreen = `fase-${i}-screen`;
                    faseBtn.addEventListener('click', () => showScreen(faseBtn.dataset.targetScreen));
                    mainScreenContent.appendChild(faseBtn);
                }
            } else {
                console.error("Error: No se encontró el elemento <main> dentro de #main-screen.");
            }
        } else {
            console.error("Error: No se encontró el elemento #main-screen.");
        }
        
        // Cargar tema guardado
        const savedTheme = localStorage.getItem('theme') || 'system';
        if (themeSelector) themeSelector.value = savedTheme;
        applyTheme(savedTheme);

        // Inicializar TTS
        if (typeof speechSynthesis !== 'undefined' && speechSynthesis.onvoiceschanged !== undefined) {
            speechSynthesis.onvoiceschanged = initializeTTS;
        }
        initializeTTS();
            await loadFaseDataFromCSV(); // Load data after TTS init
            // Initial render for the currently active fase screen, if any
            const activeScreenElement = document.querySelector(".screen.active-screen");
            if (activeScreenElement && activeScreenElement.id.startsWith("fase-") && activeScreenElement.id.endsWith("-screen")) {
                const initialFaseId = activeScreenElement.id.substring(0, activeScreenElement.id.indexOf("-screen"));
                if (appData.allFasesData[initialFaseId]) { // Ensure data is loaded
                   displayFaseContent(initialFaseId);
                } else {
                   console.log("Initial fase data not yet available for rendering.");
                }
            }


        // --- Event Listeners ---
        if (hamburgerBtn) {
             hamburgerBtn.addEventListener('click', (e) => { e.stopPropagation(); toggleOptionsMenu(true); });
        }
        if (closeOptionsBtn) closeOptionsBtn.addEventListener('click', () => toggleOptionsMenu(false));
        if (optionsOverlay) optionsOverlay.addEventListener('click', () => toggleOptionsMenu(false));
        if (optionsMenu) optionsMenu.addEventListener('click', (e) => e.stopPropagation());

        if (voiceRateElement && voiceRateValueElement) {
            voiceRateElement.addEventListener('input', function() {
                voiceRateValueElement.textContent = parseFloat(this.value).toFixed(1);
            });
        }
        if (voicePitchElement && voicePitchValueElement) {
            voicePitchElement.addEventListener('input', function() {
                voicePitchValueElement.textContent = parseFloat(this.value).toFixed(1);
            });
        }
        if (voiceVolumeElement && voiceVolumeValueElement) {
            voiceVolumeElement.addEventListener('input', function() {
                voiceVolumeValueElement.textContent = parseFloat(this.value).toFixed(1);
            });
        }

        if (ttsLanguageSelectorElement) {
            ttsLanguageSelectorElement.addEventListener('change', function() {
                ttsSettings.userPreferredLang = this.value;
                ttsSettings.selectedVoiceName = ""; // Resetear voz al cambiar idioma de filtro
                populateVoiceSelector(); // Repoblar voces con el nuevo filtro
            });
        }
         // Listener para el selector de voz, para actualizar utteranceLang inmediatamente si es necesario
        if (voiceSelectorElement) {
            voiceSelectorElement.addEventListener('change', function() {
                ttsSettings.selectedVoiceName = this.value;
                updateUtteranceLangFromSelection(); // Actualiza ttsSettings.utteranceLang
            });
        }


        if (applyChangesBtn) {
            applyChangesBtn.addEventListener('click', () => {
                console.log("Apply Changes button clicked.");
                const langPreviouslyAppliedAndSaved = localStorage.getItem('ttsUserPreferredLang');
                console.log("Language previously applied and saved (from localStorage):", langPreviouslyAppliedAndSaved);

                // Apply theme immediately
                if(themeSelector) applyTheme(themeSelector.value);

                // Update ttsSettings object from form elements
                if (ttsLanguageSelectorElement) {
                    ttsSettings.userPreferredLang = ttsLanguageSelectorElement.value;
                    console.log("TTS language selector new value being applied to ttsSettings.userPreferredLang:", ttsLanguageSelectorElement.value);
                }
                if (voiceSelectorElement) {
                    ttsSettings.selectedVoiceName = voiceSelectorElement.value;
                    updateUtteranceLangFromSelection();
                }
                if (voiceRateElement) ttsSettings.rate = parseFloat(voiceRateElement.value);
                if (voicePitchElement) ttsSettings.pitch = parseFloat(voicePitchElement.value);
                if (voiceVolumeElement) ttsSettings.volume = parseFloat(voiceVolumeElement.value);

                // Save all new settings to localStorage
                localStorage.setItem('ttsUserPreferredLang', ttsSettings.userPreferredLang);
                localStorage.setItem('ttsSelectedVoiceName', ttsSettings.selectedVoiceName);
                localStorage.setItem('ttsUtteranceLang', ttsSettings.utteranceLang);
                localStorage.setItem('ttsRate', ttsSettings.rate.toString());
                localStorage.setItem('ttsPitch', ttsSettings.pitch.toString());
                localStorage.setItem('ttsVolume', ttsSettings.volume.toString());
                console.log("New ttsSettings.userPreferredLang saved to localStorage:", ttsSettings.userPreferredLang);

                // Compare the previously saved language with the newly applied and saved language
                if (langPreviouslyAppliedAndSaved !== ttsSettings.userPreferredLang) {
                    console.log(`Language preference changed from ('${langPreviouslyAppliedAndSaved}' or initial page default) to '${ttsSettings.userPreferredLang}'. Reloading CSV data.`);
                    loadFaseDataFromCSV().then(success => {
                        if (success) {
                            const activeScreenElement = document.querySelector(".screen.active-screen");
                            if (activeScreenElement && activeScreenElement.id.startsWith("fase-") && activeScreenElement.id.endsWith("-screen")) {
                                const currentFaseId = activeScreenElement.id.substring(0, activeScreenElement.id.indexOf("-screen")).replace("-", "");
                                console.log("Refreshing content for current fase after language change:", currentFaseId);
                                displayFaseContent(currentFaseId);
                            }
                        }
                    });
                } else {
                    console.log("Language preference not changed. No CSV reload needed.");
                }

                toggleOptionsMenu(false);
            });
        }
        
        if (backToMainBtns) {
            backToMainBtns.forEach(btn => {
                btn.addEventListener('click', () => showScreen('main-screen'));
            });
        }

        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {
            if (themeSelector && themeSelector.value === 'system') {
                applyTheme('system');
            }
        });

        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('service-worker.js')
                    .then(registration => {
                        console.log('ServiceWorker registrado con éxito:', registration.scope);
                    })
                    .catch(error => {
                        console.log('Fallo en el registro de ServiceWorker:', error);
                    });
            });
        } else {
            console.log('Service Worker no es soportado en este navegador.');
        }
    });
</script>
</body>
</html>
